---
output: 
  html_document: 
pandoc_args: './common.yaml'   
params:     
config_args: "./config.yaml"
---

# Part 3: PCA and choice in number of PCS

## Load libraries
```{r load_libraries, warning=FALSE,error=FALSE,message=FALSE}
library(Seurat)
library(ggplot2)
library(kableExtra)
library(future)
library(dplyr)
library(yaml)
```

```{r prepare_inline_variables, echo = FALSE}
# get the datetime and set it to variable
todays.date <- Sys.Date()
formatted.date <- format(todays.date, format="%B %d %Y")

config.args <- read_yaml(params$config.args)
```

```{r user_vals, warning=FALSE,error=FALSE,message=FALSE, echo=FALSE}
r.obj.loc <- config.args$data$`rds-file-path`

run_tests <- config.args$analysis$run_tests
node.type <- config.args$analysis$node_type

organism <- config.args$project$organism
batch.correction.method <- config.args$analysis$part3$batch_correction

######################################################################
# Default will be no integration of the samples
######################################################################

run.normalize.data = TRUE
run.find.var.genes = TRUE
run.scale.data = TRUE

run.sctransform = FALSE

regression.vars <- c("S.Score", "G2M.Score", "percent.mito", "nFeature_RNA")

if (batch.correction.method %in% c("orig", "orig_ident", "orig.ident"){
  append(regression.vars, "orig.ident")
} else if (batch.correction.method == "sctransform"){
  run.normalize.data = FALSE
  run.find.var.genes = FALSE
  run.scale.data = FALSE
  
  run.sctransform = TRUE
}


part2.suffix <- config.args$analysis$part2$part2_suffix
part3.suffix <- config.args$analysis$part3$part3_suffix

part3.rds.open.file <- config.args$analysis$part3$part3_rds_open_filename
part3.rds.open.file <- sub(".RDS", paste0(part2.suffix, ".RDS"), part3.rds.open.file )
part3.rds.open.path <- file.path(r.obj.loc, part3.rds.open.file)

part3.rds.save.file <- config.args$analysis$part3$part3_rds_save_filename
part3.rds.save.file <- sub(".RDS", paste0(part3.suffix, ".RDS"), part3.rds.save.file )
part3.rds.save.path <- file.path(r.obj.loc, part3.rds.save.file)

part3.file.for.report <- config.args$analysis$part3$part3_report_stuff_filename
part3.file.for.report <- sub(".RData", paste0(part3.suffix, ".RData"), part3.file.for.report )
part3.file.report.path <- file.path(r.obj.loc, part3.file.for.report)

```

### This report was generated on `r formatted.date`

* node.type: `r node.type`
* batch correction method: `r batch.correction.method`

* starting with rds object at `r part3.rds.open.path`
* saving rds object to `r part3.rds.save.path`
* saving file for report at `r part3.file.report.path`


```{r get_n.cores, echo = FALSE}
if (node.type == "compute"){
  # If using a compute node, then put this in the submission script:
  # export MC_CORES=${SLURM_NTASKS}
  n.cores <- as.numeric(Sys.getenv("SLURM_NTASKS"))
} else {
  library(parallel) 
  n.cores <- detectCores() 
}
```

## Load the Seurat object from part 2

```{r load_data, warning=FALSE,error=FALSE,message=FALSE}
experiment.aggregate <- readRDS(file=part3.rds.open.path)
```


## Next we want to normalize the data

After filtering out cells from the dataset, the next step is to normalize the data. By default, we employ a global-scaling normalization method LogNormalize that normalizes the gene expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and then log-transforms the data.

```{r normalize_help, warning=FALSE,error=FALSE,message=FALSE, eval=FALSE}
?NormalizeData
```

```{r normalize, warning=FALSE,error=FALSE,message=FALSE, eval=run.normalize.data}
max.size <- (as.numeric(object.size(experiment.aggregate)) * 1.2)
options(future.globals.maxSize= max.size)

print(paste0("max.size = ", max.size, ", n.cores = ", n.cores))
plan("multisession", workers = n.cores) # multithreading

experiment.aggregate <- NormalizeData(
  object = experiment.aggregate,
  normalization.method = "LogNormalize",
  scale.factor = 10000)
```

### Calculate Cell-Cycle with Seurat
[Dissecting the multicellular ecosystem of metastatic melanoma by single-cell RNA-seq](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4944528/)

The list of genes comes with Seurat (only for human). We can use biomaRt to convert the human gene symbols to mouse.


```{r cellcycle, warning=FALSE,error=FALSE,message=FALSE}
# Mouse Code
convertHumanGeneList <- function(x){
  require("biomaRt")
  human <- useMart("ensembl", dataset = "hsapiens_gene_ensembl", host = "https://dec2021.archive.ensembl.org/") 
  mouse <- useMart("ensembl", dataset = "mmusculus_gene_ensembl", host = "https://dec2021.archive.ensembl.org/")

  genes = getLDS(attributes = c("hgnc_symbol"), filters = "hgnc_symbol", values = x, mart = human, attributesL = c("mgi_symbol"), martL = mouse, uniqueRows=T)

  humanx <- unique(genes[, 2])

  # Print the first 6 genes found to the screen
  print(head(humanx))
  return(humanx)
}

if (organism == "mouse"){
  m.s.genes <- convertHumanGeneList(cc.genes.updated.2019$s.genes)
  m.g2m.genes <- convertHumanGeneList(cc.genes.updated.2019$g2m.genes)

  # Create our Seurat object and complete the initialization steps
  experiment.aggregate <- CellCycleScoring(experiment.aggregate, s.features = m.s.genes, g2m.features = m.g2m.genes, set.ident = TRUE)
} else if (organism == "human"){
  # Human Code
  s.genes <- (cc.genes$s.genes)
  g2m.genes <- (cc.genes$g2m.genes)
  
  # Create our Seurat object and complete the initialization steps
  experiment.aggregate <- CellCycleScoring(experiment.aggregate, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)
}
```

#### Table of cell cycle (seurate)

```{r cellcycle_table, warning=FALSE,error=FALSE,message=FALSE}
cell.cycle.table <- table(experiment.aggregate@meta.data$Phase) %>% kable(caption = "Number of Cells in each Cell Cycle Stage", col.names = c("Stage", "Count"), align = "c") %>% kable_styling()

cell.cycle.table
```

#### Fixing the defualt "Ident" in Seurat

```{r update_ident, warning=FALSE,error=FALSE,message=FALSE}
table(Idents(experiment.aggregate))
## So lets change it back to samplename
Idents(experiment.aggregate) <- "orig.ident"
table(Idents(experiment.aggregate))
```


## Identify variable genes

The function FindVariableFeatures identifies the most highly variable genes (default 2000 genes) by fitting a line to the relationship of log(variance) and log(mean) using loess smoothing, uses this information to standardize the data, then calculates the variance of the standardized data.  This helps avoid selecting genes that only appear variable due to their expression level.

```{r fine_variable_genes_help, warning=FALSE,error=FALSE, message=FALSE, eval=FALSE}
?FindVariableFeatures
```

```{r find_variable_genes, warning=FALSE,error=FALSE,message=FALSE, eval = F, echo= F}
# experiment.aggregate <- FindVariableFeatures(
#   object = experiment.aggregate,
#   selection.method = "vst")
# 
# length(VariableFeatures(experiment.aggregate))
# 
# top10 <- head(VariableFeatures(experiment.aggregate), 10)
# 
# top10
# 
# vfp1 <- VariableFeaturePlot(experiment.aggregate)
# vfp1 <- LabelPoints(plot = vfp1, points = top10, repel = TRUE)
# vfp1
```

However, instead of using the variable genes function, lets instead assign variable genes to a set of "minimally expressed" genes.

```{r our_variable_genes, warning=FALSE,error=FALSE,message=FALSE, eval=run.find.var.genes}
dim(experiment.aggregate)

min.value = 1
min.cells = 10
num.cells <- Matrix::rowSums(GetAssayData(experiment.aggregate, slot = "count") > min.value)
genes.use <- names(num.cells[which(num.cells >= min.cells)])
length(genes.use)

VariableFeatures(experiment.aggregate) <- genes.use

```


### Scale Data

ScaleData - Scales and centers genes in the dataset. If variables are provided in vars.to.regress, they are individually regressed against each gene, and the resulting residuals are then scaled and centered unless otherwise specified. Here we regress out cell cycle results S.Score and G2M.Score, percentage mitochondria (percent.mito) and the number of features (nFeature_RNA).

```{r scale_data, warning=FALSE,error=FALSE,message=FALSE, eval = run.scale.data}
max.size <- (as.numeric(object.size(experiment.aggregate)) * 3.0)
options(future.globals.maxSize= max.size)

plan("multisession", workers = n.cores) # multithreading
experiment.aggregate <- ScaleData(
  object = experiment.aggregate,
  vars.to.regress = regression.vars)
```


```{r sample_integration, warning=FALSE,error=FALSE,message=FALSE, eval = run.sctransform, echo = run.sctransform}
max.size <- (as.numeric(object.size(experiment.aggregate)) * 3.0)
options(future.globals.maxSize= max.size)

if (node.type == "analytics"){
  plan("multisession", workers = n.cores) # multithreading
}

seurat.obj.list <- SplitObject(experiment.aggregate, split.by = "orig.ident")

for (i in 1:length(seurat.obj.list)) {
    seurat.obj.list[[i]] <- SCTransform(seurat.obj.list[[i]], verbose = FALSE)
}

experiment.aggregate.features <- SelectIntegrationFeatures(object.list = seurat.obj.list, nfeatures = 3000)

seurat.obj.list <- PrepSCTIntegration(object.list = seurat.obj.list, anchor.features = experiment.aggregate.features, verbose = FALSE)

experiment.aggregate.anchors <- FindIntegrationAnchors(object.list = seurat.obj.list, normalization.method = "SCT", anchor.features = experiment.aggregate.features, verbose = FALSE)

experiment.aggregate <- IntegrateData(anchorset = experiment.aggregate.anchors, normalization.method = "SCT", verbose = FALSE)


```

## Dimensionality reduction with PCA

Next we perform PCA (principal components analysis) on the scaled data.  

```{r pca_help, warning=FALSE,error=FALSE,message=FALSE, eval=FALSE, echo = FALSE}
?RunPCA
```

```{r pca, warning=FALSE,error=FALSE,message=FALSE}
experiment.aggregate <- RunPCA(object = experiment.aggregate, npcs=100)
```

Seurat then provides a number of ways to visualize the PCA results

Visualize PCA loadings
```{r viz_pca, warning=FALSE,error=FALSE,message=FALSE}
pca.loadings.1 <- VizDimLoadings(experiment.aggregate, dims = 1, ncol = 1) + theme_minimal(base_size = 8)
pca.loadings.2 <- VizDimLoadings(experiment.aggregate, dims = 2, ncol = 1) + theme_minimal(base_size = 8)

pca.loadings.1
pca.loadings.2
```

Principal components plot
```{r plot_pca, warning=FALSE,error=FALSE,message=FALSE}
pca.plot <- DimPlot(object = experiment.aggregate, reduction = "pca")

pca.plot
```

Draws a heatmap focusing on a principal component. Both cells and genes are sorted by their principal component scores. Allows for nice visualization of sources of heterogeneity in the dataset.

```{r heatmap_pca, warning=FALSE,error=FALSE,message=FALSE}
pca.heatmap.1 <- DimHeatmap(object = experiment.aggregate, dims = 1:6, cells = 500, balanced = TRUE, fast = FALSE)

pca.heatmap.2 <- DimHeatmap(object = experiment.aggregate, dims = 7:12, cells = 500, balanced = TRUE, fast = FALSE)

pca.heatmap.1
pca.heatmap.2
```

### Selecting which PCs to use
To overcome the extensive technical noise in any single gene, Seurat clusters cells based on their PCA scores, with each PC essentially representing a metagene that combines information across a correlated gene set. Determining how many PCs to include downstream is therefore an important step.

ElbowPlot plots the standard deviations (or approximate singular values if running PCAFast) of the principle components for easy identification of an elbow in the graph. This elbow often corresponds well with the significant PCs and is much faster to run.  This is the traditional approach to selecting principal components.

```{r elbow, warning=FALSE,error=FALSE,message=FALSE}
elbow.plot <- ElbowPlot(experiment.aggregate, ndims = 100)

elbow.plot
```


```{r cell_cycle_table, warning=FALSE, error=FALSE, message=FALSE}
cell.cycle.table <- table(experiment.aggregate@meta.data$Phase) %>% kable(caption = "Number of Cells in each Cell Cycle Stage", col.names = c("Stage", "Count"), align = "c") %>% kable_styling()

```
## Finally, lets save the filtered and normalized data
```{r save_rdata, warning=FALSE,error=FALSE,message=FALSE}
saveRDS(experiment.aggregate, file=part3.rds.save.path)

to.save.for.report <- c("pca.loadings.1",
                        "pca.loadings.2",
                        "pca.plot",
                        "elbow.plot",
                        "pca.heatmap.1",
                        "pca.heatmap.2",
                        "cell.cycle.table")

save(list = to.save.for.report, file=part3.file.report.path)
```

## Session Information
```{r session_info, warning=FALSE,error=FALSE,message=FALSE}
sessionInfo()
```
